<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Daisuke v1.2 Chatbot</title>
  <style>
    body { background: #111; color: #eee; font-family: sans-serif; padding: 20px; }
    #chat { max-width: 600px; margin: auto; background: #222; padding: 20px; border-radius: 10px; }
    .message { margin-bottom: 10px; }
    .user { color: #0f0; }
    .bot { color: #00ffff; }
    input, button {
      padding: 10px;
      font-size: 1rem;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div id="chat">
    <h2>Daisuke v1.2 🤖</h2>
    <div id="chat-window"></div>
    <input type="text" id="userInput" placeholder="Ask something..." />
    <button onclick="handleInput()">Send</button>
  </div>

  <script>
    const questionWords = ["what", "who", "how", "why", "where", "when", "which", "whom", "whose"];
    const shownResponses = new Set(); // To handle duplicates

    async function handleInput() {
      const input = document.getElementById('userInput').value.trim();
      if (!input) return;
      appendMessage("You: " + input, "user");

      const clean = removeQuestionWords(input);
      const words = clean.split(/\s+/);
      const firstWord = words[0]?.toLowerCase();
      if (!firstWord) return appendMessage("Daisuke: ❓ Please ask a more detailed question.", "bot");

      const firstLetter = firstWord[0];

      // Reset shown response set for this query
      shownResponses.clear();

      // Step 1: Check in custom/
      let response = await searchJSON(`custom/${firstLetter}.json`, clean, [0.85, 0.65], true);
      if (response) return appendMessage("Daisuke: " + response, "bot");

      // Step 2: Check in commen/
      response = await searchJSON(`commen/${firstLetter}/${firstLetter}.json`, clean, [0.85, 0.65], true);
      if (response) return appendMessage("Daisuke: " + response, "bot");

      // Step 3: Keyword-based search in data/
      const keywords = clean.split(/\s+/);
      const matches = [];
      for (let keyword of keywords) {
        const k1 = keyword[0]?.toLowerCase();
        const k2 = keyword[1]?.toLowerCase();
        if (!k1 || !k2) continue;
        const path = `data/${k1}/${k2}.json`;
        const match = await searchJSON(path, keyword, [0.9, 0.4], false);
        if (match && !shownResponses.has(match)) {
          shownResponses.add(match);
          matches.push(`🔹 ${match}`);
        }
      }

      if (matches.length > 0) {
        appendMessage("Daisuke:\n" + matches.join("\n"), "bot");
      } else {
        appendMessage("Daisuke: 🤔 I couldn't find a good match. Please try rephrasing.", "bot");
      }
    }

    function removeQuestionWords(sentence) {
      const tokens = sentence.toLowerCase().split(/\s+/);
      return tokens.filter(word => !questionWords.includes(word)).join(" ");
    }

    function appendMessage(text, className) {
      const chat = document.getElementById('chat-window');
      const div = document.createElement('div');
      div.className = 'message ' + className;
      div.textContent = text;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    async function searchJSON(url, input, thresholds = [0.85, 0.65], treatUnderscoreAsSpace = true) {
      try {
        const res = await fetch(url);
        if (!res.ok) return null;
        const data = await res.json();
        for (const threshold of thresholds) {
          for (const key in data) {
            let keyProcessed = treatUnderscoreAsSpace ? key.replace(/_/g, " ") : key;
            if (similarity(input.toLowerCase(), keyProcessed.toLowerCase()) >= threshold) {
              const answer = data[key];
              if (!shownResponses.has(answer)) {
                shownResponses.add(answer);
                return answer;
              }
            }
          }
        }
      } catch (err) {
        return null;
      }
      return null;
    }

    function similarity(s1, s2) {
      let longer = s1.length > s2.length ? s1 : s2;
      let shorter = s1.length > s2.length ? s2 : s1;
      let longerLength = longer.length;
      if (longerLength === 0) return 1.0;
      return (longerLength - editDistance(longer, shorter)) / longerLength;
    }

    function editDistance(s1, s2) {
      const costs = Array(s2.length + 1).fill().map(() => 0);
      for (let i = 0; i <= s1.length; i++) {
        let lastValue = i;
        for (let j = 0; j <= s2.length; j++) {
          if (i === 0) costs[j] = j;
          else if (j > 0) {
            let newValue = costs[j - 1];
            if (s1[i - 1] !== s2[j - 1]) newValue = Math.min(newValue, lastValue, costs[j]) + 1;
            costs[j - 1] = lastValue;
            lastValue = newValue;
          }
        }
        if (i > 0) costs[s2.length] = lastValue;
      }
      return costs[s2.length];
    }
  </script>
</body>
</html>
